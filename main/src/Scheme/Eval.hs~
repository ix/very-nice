{-# LANGUAGE OverloadedStrings #-}

module Scheme.Eval
  ( showVal
  , eval )
  where

import Data.Text (Text)
import qualified Data.Text as T
import Data.Complex
import Data.Ratio

import Scheme.LispVal

instance Show LispVal where show = T.unpack . showVal

showVal :: LispVal -> Text
showVal (String contents) = "\"" `T.append` contents `T.append` "\""
showVal (Atom name) = name
showVal (Number contents) = T.pack $ show contents
showVal (Float contents) = T.pack $ show contents
showVal (Bool True) = "#t"
showVal (Bool False) = "#f"
showVal (List contents) = "(" `T.append` unwordsList contents `T.append` ")"
showVal (DottedList head tail) = "(" `T.append` unwordsList head `T.append` " . " `T.append` showVal tail `T.append` ")"

unwordsList :: [LispVal] -> Text
unwordsList = T.unwords . map showVal

eval :: LispVal -> LispVal
-- self-evaluating
eval val@(String _) = val
eval val@(Number _) = val
eval val@(Bool _) = val
eval (List [Atom "quote", val]) = val
eval (List (Atom func : args)) = apply func $ map eval args

apply :: Text -> [LispVal] -> LispVal
apply func args = maybe (Bool False) ($ args) $ lookup func primitives

primitives :: [(Text, [LispVal] -> LispVal)]
primitives = [ ("+", numericBinop (+))
             , ("-", numericBinop (-))
             , ("*", numericBinop (*))
             , ("/", numericBinop div)
             , ("mod", numericBinop mod)
             , ("quotient", numericBinop quot)
             , ("remainder", numericBinop rem)

             , ("boolean?", unaryOp boolp)
             , ("pair?", unaryOp pairp)
             , ("list?", unaryOp listp)
             , ("symbol?", unaryOp symbolp)
             , ("char?", unaryOp charp)
             , ("string?", unaryOp stringp)
             , ("vector?", unaryOp vectorp)

             , ("number?", unaryOp numberp)
             , ("complex?", unaryOp complexp)
             , ("real?", unaryOp realp)
             , ("rational?", unaryOp rationalp)
             , ("integer?", unaryOp integerp)]

numericBinop :: (Num a) => (a -> a -> a) -> [LispVal] -> LispVal
numericBinop op params = Number $ foldl1 op $ map unpackNum params

-- TODO
unpackNum :: LispVal -> Integer
unpackNum (Number n) = n
unpackNum _ = 0

unaryOp :: (LispVal -> LispVal) -> [LispVal] -> LispVal
unaryOp f [v] = f v 

-- type testing
symbolp :: LispVal -> LispVal
pairp   :: LispVal -> LispVal
listp   :: LispVal -> LispVal
boolp   :: LispVal -> LispVal
charp   :: LispVal -> LispVal
stringp :: LispVal -> LispVal
vectorp :: LispVal -> LispVal

symbolp (Atom _) = Bool True
symbolp _ = Bool False
pairp (List _) = Bool True
pairp (DottedList _ _) = Bool True
pairp _  = Bool False
listp (List _) = Bool True
listp _ = Bool False
boolp (Bool _) = Bool True
boolp _ = Bool False
charp (Character _) = Bool True
charp _ = Bool False
stringp (String _) = Bool True
stringp _ = Bool False
vectorp (Vector _) = Bool True
vectorp _ = Bool False

-- numerals
numberp   :: LispVal -> LispVal
complexp  :: LispVal -> LispVal
realp     :: LispVal -> LispVal
rationalp :: LispVal -> LispVal
integerp  :: LispVal -> LispVal

numberp = complexp
complexp (Complex _) = Bool True
complexp x = realp x
realp (Float _) = Bool True
realp x = rationalp x
rationalp (Ratio x) = Bool True
rationalp x = integerp x
integerp (Number x) = Bool True
integerp _ = Bool False
